<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>03_Graphs_Presentation</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<section id="поданняпрезентація-графа" class="level2">
<h2>Подання/презентація графа</h2>
<hr />
<p>Графи зазвичай подаються способами:</p>
<ul>
<li><strong>Матриця</strong> суміжності (Adjacency Matrix).</li>
<li><strong>Список</strong> суміжності (Adjacency List).</li>
</ul>
<p><strong>Матриця суміжності</strong> є двовимірним масивом вершин <code>V x V</code>. Кожен рядок і стовпець є вершиною.</p>
<p>Якщо значення, наприклад, будь-якого елемента <code>a[i][j]</code> дорівнює 1, це означає, що існує ребро, що з’єднує вершину <code>i</code> та вершину <code>j</code></p>
<p><strong>Базові операції</strong>, такі як додавання ребра, видалення ребра та перевірка наявності ребра з вершини <code>i</code> у вершину <code>j</code>, є надзвичайно ефективними за часом операціями із постійним часом. Якщо граф щільний та кількість ребер велика, матриця суміжності має бути першим вибором. Навіть якщо граф та матриця суміжності розріджені, ми можемо представити їх, використовуючи структури даних для розріджених матриць.</p>
<p>Вимога до простору <code>V x V</code> для матриці суміжності робить її жадібною до пам’яті. Графи в житті зазвичай не мають занадто великої кількості з’єднань, і це основна причина, через яку списки суміжності є найкращим вибором для більшості завдань.</p>
<p><code>Big-O</code> для Adjacency Matrix</p>
<ul>
<li>додавання <code>O(1)</code></li>
<li>видалення <code>O(1)</code></li>
<li>ініціалізація <code>O(N * N)</code></li>
</ul>
<p><strong>Список суміжності</strong> представляє граф як масив пов’язаних списків. Індекс масиву є вершиною, а кожен елемент у його пов’язаному списку представляє інші вершини, що утворюють ребро з цією вершиною.</p>
<p>Список суміжності ефективний з точки зору зберігання, тому що нам потрібно зберігати лише значення для ребер. Для розрідженого графа, наприклад, з мільйонами вершин та ребер, це може означати велику економію місця. Це також допомагає легко знайти всі вершини, суміжні з вершиною.</p>
<p>Пошук суміжного списку не швидше, ніж матриця суміжності, тому що всі пов’язані вузли повинні бути спочатку досліджені, щоб знайти їх.</p>
<p><code>Big-O</code> для Adjacency List</p>
<ul>
<li>додавання <code>O(1)</code></li>
<li>видалення <code>O(N)</code></li>
<li>ініціалізація <code>O(N)</code></li>
</ul>
</section>
</body>
</html>
